<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>EVP_PKEY_CTX_ctrl</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#rsa_parameters">RSA parameters</a></li>
		<li><a href="#dsa_parameters">DSA parameters</a></li>
		<li><a href="#dh_parameters">DH parameters</a></li>
		<li><a href="#dh_key_derivation_function_parameters">DH key derivation function parameters</a></li>
		<li><a href="#ec_parameters">EC parameters</a></li>
		<li><a href="#ecdh_parameters">ECDH parameters</a></li>
		<li><a href="#ecdh_key_derivation_function_parameters">ECDH key derivation function parameters</a></li>
		<li><a href="#other_parameters">Other parameters</a></li>
	</ul>

	<li><a href="#return_values">RETURN VALUES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>EVP_PKEY_CTX_get_params,
EVP_PKEY_CTX_gettable_params,
EVP_PKEY_CTX_set_params,
EVP_PKEY_CTX_settable_params,
EVP_PKEY_CTX_ctrl,
EVP_PKEY_CTX_ctrl_str,
EVP_PKEY_CTX_ctrl_uint64,
EVP_PKEY_CTX_md,
EVP_PKEY_CTX_set_signature_md,
EVP_PKEY_CTX_get_signature_md,
EVP_PKEY_CTX_set_mac_key,
EVP_PKEY_CTX_set_rsa_padding,
EVP_PKEY_CTX_get_rsa_padding,
EVP_PKEY_CTX_set_rsa_pss_saltlen,
EVP_PKEY_CTX_get_rsa_pss_saltlen,
EVP_PKEY_CTX_set_rsa_keygen_bits,
EVP_PKEY_CTX_set_rsa_keygen_pubexp,
EVP_PKEY_CTX_set_rsa_keygen_primes,
EVP_PKEY_CTX_set_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_mgf1_md,
EVP_PKEY_CTX_get_rsa_mgf1_md,
EVP_PKEY_CTX_get_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md,
EVP_PKEY_CTX_get_rsa_oaep_md,
EVP_PKEY_CTX_get_rsa_oaep_md_name,
EVP_PKEY_CTX_set0_rsa_oaep_label,
EVP_PKEY_CTX_get0_rsa_oaep_label,
EVP_PKEY_CTX_set_dsa_paramgen_bits,
EVP_PKEY_CTX_set_dsa_paramgen_q_bits,
EVP_PKEY_CTX_set_dsa_paramgen_md,
EVP_PKEY_CTX_set_dh_paramgen_prime_len,
EVP_PKEY_CTX_set_dh_paramgen_subprime_len,
EVP_PKEY_CTX_set_dh_paramgen_generator,
EVP_PKEY_CTX_set_dh_paramgen_type,
EVP_PKEY_CTX_set_dh_rfc5114,
EVP_PKEY_CTX_set_dhx_rfc5114,
EVP_PKEY_CTX_set_dh_pad,
EVP_PKEY_CTX_set_dh_nid,
EVP_PKEY_CTX_set_dh_kdf_type,
EVP_PKEY_CTX_get_dh_kdf_type,
EVP_PKEY_CTX_set0_dh_kdf_oid,
EVP_PKEY_CTX_get0_dh_kdf_oid,
EVP_PKEY_CTX_set_dh_kdf_md,
EVP_PKEY_CTX_get_dh_kdf_md,
EVP_PKEY_CTX_set_dh_kdf_outlen,
EVP_PKEY_CTX_get_dh_kdf_outlen,
EVP_PKEY_CTX_set0_dh_kdf_ukm,
EVP_PKEY_CTX_get0_dh_kdf_ukm,
EVP_PKEY_CTX_set_ec_paramgen_curve_nid,
EVP_PKEY_CTX_set_ec_param_enc,
EVP_PKEY_CTX_set_ecdh_cofactor_mode,
EVP_PKEY_CTX_get_ecdh_cofactor_mode,
EVP_PKEY_CTX_set_ecdh_kdf_type,
EVP_PKEY_CTX_get_ecdh_kdf_type,
EVP_PKEY_CTX_set_ecdh_kdf_md,
EVP_PKEY_CTX_get_ecdh_kdf_md,
EVP_PKEY_CTX_set_ecdh_kdf_outlen,
EVP_PKEY_CTX_get_ecdh_kdf_outlen,
EVP_PKEY_CTX_set0_ecdh_kdf_ukm,
EVP_PKEY_CTX_get0_ecdh_kdf_ukm,
EVP_PKEY_CTX_set1_id, EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len
- algorithm specific control operations</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 #include &lt;openssl/evp.h&gt;</pre>
<pre>
 int EVP_PKEY_CTX_get_params(EVP_PKEY_CTX *ctx, OSSL_PARAM *params);
 const OSSL_PARAM *EVP_PKEY_CTX_gettable_params(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_CTX_set_params(EVP_PKEY_CTX *ctx, OSSL_PARAM *params);
 const OSSL_PARAM *EVP_PKEY_CTX_settable_params(EVP_PKEY_CTX *ctx);</pre>
<pre>
 int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
                       int cmd, int p1, void *p2);
 int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
                              int cmd, uint64_t value);
 int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                           const char *value);</pre>
<pre>
 int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd, const char *md);</pre>
<pre>
 int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_get_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD **pmd);</pre>
<pre>
 int EVP_PKEY_CTX_set_mac_key(EVP_PKEY_CTX *ctx, const unsigned char *key,
                              int len);</pre>
<pre>
 #include &lt;openssl/rsa.h&gt;</pre>
<pre>
 int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);
 int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx, int *pad);
 int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int saltlen);
 int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int *saltlen);
 int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);
 int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);
 int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx, int primes);
 int EVP_PKEY_CTX_set_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx, const char *mdname,
                                     const char *mdprops);
 int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
 int EVP_PKEY_CTX_get_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx, char *name,
                                       size_t namelen);
 int EVP_PKEY_CTX_set_rsa_oaep_md_name(EVP_PKEY_CTX *ctx, const char *mdname,
                                       const char *mdprops);
 int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_get_rsa_oaep_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
 int EVP_PKEY_CTX_get_rsa_oaep_md_name(EVP_PKEY_CTX *ctx, char *name,
                                       size_t namelen)
 int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, unsigned char *label, int len);
 int EVP_PKEY_CTX_get0_rsa_oaep_label(EVP_PKEY_CTX *ctx, unsigned char **label);</pre>
<pre>
 #include &lt;openssl/dsa.h&gt;</pre>
<pre>
 int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);
 int EVP_PKEY_CTX_set_dsa_paramgen_q_bits(EVP_PKEY_CTX *ctx, int qbits);
 int EVP_PKEY_CTX_set_dsa_paramgen_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);</pre>
<pre>
 #include &lt;openssl/dh.h&gt;</pre>
<pre>
 int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);
 int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(EVP_PKEY_CTX *ctx, int len);
 int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);
 int EVP_PKEY_CTX_set_dh_paramgen_type(EVP_PKEY_CTX *ctx, int type);
 int EVP_PKEY_CTX_set_dh_pad(EVP_PKEY_CTX *ctx, int pad);
 int EVP_PKEY_CTX_set_dh_nid(EVP_PKEY_CTX *ctx, int nid);
 int EVP_PKEY_CTX_set_dh_rfc5114(EVP_PKEY_CTX *ctx, int rfc5114);
 int EVP_PKEY_CTX_set_dhx_rfc5114(EVP_PKEY_CTX *ctx, int rfc5114);
 int EVP_PKEY_CTX_set_dh_kdf_type(EVP_PKEY_CTX *ctx, int kdf);
 int EVP_PKEY_CTX_get_dh_kdf_type(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_CTX_set0_dh_kdf_oid(EVP_PKEY_CTX *ctx, ASN1_OBJECT *oid);
 int EVP_PKEY_CTX_get0_dh_kdf_oid(EVP_PKEY_CTX *ctx, ASN1_OBJECT **oid);
 int EVP_PKEY_CTX_set_dh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_get_dh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
 int EVP_PKEY_CTX_set_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int len);
 int EVP_PKEY_CTX_get_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int *len);
 int EVP_PKEY_CTX_set0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char *ukm, int len);
 int EVP_PKEY_CTX_get0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char **ukm);</pre>
<pre>
 #include &lt;openssl/ec.h&gt;</pre>
<pre>
 int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);
 int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int param_enc);
 int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx, int cofactor_mode);
 int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_CTX_set_ecdh_kdf_type(EVP_PKEY_CTX *ctx, int kdf);
 int EVP_PKEY_CTX_get_ecdh_kdf_type(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_CTX_set_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_get_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
 int EVP_PKEY_CTX_set_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int len);
 int EVP_PKEY_CTX_get_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int *len);
 int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char *ukm, int len);
 int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char **ukm);</pre>
<pre>
 int EVP_PKEY_CTX_set1_id(EVP_PKEY_CTX *ctx, void *id, size_t id_len);
 int EVP_PKEY_CTX_get1_id(EVP_PKEY_CTX *ctx, void *id);
 int EVP_PKEY_CTX_get1_id_len(EVP_PKEY_CTX *ctx, size_t *id_len);</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The <code>EVP_PKEY_CTX_get_params()</code> and <code>EVP_PKEY_CTX_set_params()</code> functions get and
send arbitrary parameters from and to the algorithm implementation respectively.
Not all parameters may be supported by all providers.
See <em>OSSL_PROVIDER(3)</em> for more information on providers.
See <em>OSSL_PARAM(3)</em> for more information on parameters.
These functions must only be called after the EVP_PKEY_CTX has been initialised
for use in an operation.</p>
<p>The parameters currently supported by the default provider are:</p>
<dl>
<dt><strong><a name="pad_ossl_exchange_param_pad_unsigned_integer" class="item">&quot;pad&quot; (<strong>OSSL_EXCHANGE_PARAM_PAD</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Sets the DH padding mode.
If <strong>OSSL_EXCHANGE_PARAM_PAD</strong> is 1 then the  shared secret is padded with zeros
up to the size of the DH prime <em>p</em>.
If <strong>OSSL_EXCHANGE_PARAM_PAD</strong> is zero (the default) then no padding is
performed.</p>
</dd>
<dt><strong><a name="digest_ossl_signature_param_digest_utf8_string" class="item">&quot;digest&quot; (<strong>OSSL_SIGNATURE_PARAM_DIGEST</strong>) &lt;UTF8 string&gt;</a></strong></dt>

<dd>
<p>Gets and sets the name of the digest algorithm used for the input to the
signature functions.</p>
</dd>
<dt><strong><a name="digest_size_ossl_signature_param_digest_size_unsigned_integer" class="item">&quot;digest-size&quot; (<strong>OSSL_SIGNATURE_PARAM_DIGEST_SIZE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets and sets the output size of the digest algorithm used for the input to the
signature functions.
The length of the &quot;digest-size&quot; parameter should not exceed that of a <strong>size_t</strong>.
The internal algorithm that supports this parameter is DSA.</p>
</dd>
</dl>
<p><code>EVP_PKEY_CTX_gettable_params()</code> and <code>EVP_PKEY_CTX_settable_params()</code> gets a
constant <strong>OSSL_PARAM</strong> array that describes the  gettable and
settable parameters for the current algorithm implementation, i.e. parameters
that can be used with <code>EVP_PKEY_CTX_get_params()</code> and <code>EVP_PKEY_CTX_set_params()</code>
respectively.
See <em>OSSL_PARAM(3)</em> for the use of <strong>OSSL_PARAM</strong> as parameter descriptor.
These functions must only be called after the EVP_PKEY_CTX has been initialised
for use in an operation.</p>
<p>The function <code>EVP_PKEY_CTX_ctrl()</code> sends a control operation to the context
<em>ctx</em>. The key type used must match <em>keytype</em> if it is not -1. The parameter
<em>optype</em> is a mask indicating which operations the control can be applied to.
The control command is indicated in <em>cmd</em> and any additional arguments in
<em>p1</em> and <em>p2</em>.</p>
<p>For <em>cmd</em> = <strong>EVP_PKEY_CTRL_SET_MAC_KEY</strong>, <em>p1</em> is the length of the MAC key,
and <em>p2</em> is the MAC key. This is used by Poly1305, SipHash, HMAC and CMAC.</p>
<p>Applications will not normally call <code>EVP_PKEY_CTX_ctrl()</code> directly but will
instead call one of the algorithm specific macros below.</p>
<p>The function EVP_PKEY_CTX_ctrl_uint64() is a wrapper that directly passes a
uint64 value as <em>p2</em> to <code>EVP_PKEY_CTX_ctrl()</code>.</p>
<p>The function <code>EVP_PKEY_CTX_ctrl_str()</code> allows an application to send an algorithm
specific control operation to a context <em>ctx</em> in string form. This is
intended to be used for options specified on the command line or in text
files. The commands supported are documented in the openssl utility
command line pages for the option <em>-pkeyopt</em> which is supported by the
<em>pkeyutl</em>, <em>genpkey</em> and <em>req</em> commands.</p>
<p>The function <code>EVP_PKEY_CTX_md()</code> sends a message digest control operation
to the context <em>ctx</em>. The message digest is specified by its name <em>md</em>.</p>
<p>The <code>EVP_PKEY_CTX_set_signature_md()</code> function sets the message digest type used
in a signature. It can be used in the RSA, DSA and ECDSA algorithms.</p>
<p>The <code>EVP_PKEY_CTX_get_signature_md()</code> function gets the message digest type used
in a signature. It can be used in the RSA, DSA and ECDSA algorithms.</p>
<p>All the remaining &quot;functions&quot; are implemented as macros.</p>
<p>Key generation typically involves setting up parameters to be used and
generating the private and public key data. Some algorithm implementations
allow private key data to be set explicitly using the <code>EVP_PKEY_CTX_set_mac_key()</code>
macro. In this case key generation is simply the process of setting up the
parameters for the key and then setting the raw key data to the value explicitly
provided by that macro. Normally applications would call
<em>EVP_PKEY_new_raw_private_key(3)</em> or similar functions instead of this macro.</p>
<p>The <code>EVP_PKEY_CTX_set_mac_key()</code> macro can be used with any of the algorithms
supported by the <em>EVP_PKEY_new_raw_private_key(3)</em> function.</p>
<p>
</p>
<h2><a name="rsa_parameters">RSA parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_rsa_padding()</code> function sets the RSA padding mode for <em>ctx</em>.
The <em>pad</em> parameter can take the value <strong>RSA_PKCS1_PADDING</strong> for PKCS#1
padding, <strong>RSA_SSLV23_PADDING</strong> for SSLv23 padding, <strong>RSA_NO_PADDING</strong> for
no padding, <strong>RSA_PKCS1_OAEP_PADDING</strong> for OAEP padding (encrypt and
decrypt only), <strong>RSA_X931_PADDING</strong> for X9.31 padding (signature operations
only), <strong>RSA_PKCS1_PSS_PADDING</strong> (sign and verify only) and
<strong>RSA_PKCS1_WITH_TLS_PADDING</strong> for TLS RSA ClientKeyExchange message padding
(decryption only).</p>
<p>Two RSA padding modes behave differently if <code>EVP_PKEY_CTX_set_signature_md()</code>
is used. If this macro is called for PKCS#1 padding the plaintext buffer is
an actual digest value and is encapsulated in a DigestInfo structure according
to PKCS#1 when signing and this structure is expected (and stripped off) when
verifying. If this control is not used with RSA and PKCS#1 padding then the
supplied data is used directly and not encapsulated. In the case of X9.31
padding for RSA the algorithm identifier byte is added or checked and removed
if this control is called. If it is not called then the first byte of the plaintext
buffer is expected to be the algorithm identifier byte.</p>
<p>The <code>EVP_PKEY_CTX_get_rsa_padding()</code> function gets the RSA padding mode for <em>ctx</em>.</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_pss_saltlen()</code> function sets the RSA PSS salt
length to <em>saltlen</em>. As its name implies it is only supported for PSS
padding. If this function is not called then the maximum salt length
is used when signing and auto detection when verifying. Three special
values are supported:</p>
<dl>
<dt><strong><a name="rsa_pss_saltlen_digest" class="item"><strong>RSA_PSS_SALTLEN_DIGEST</strong></a></strong></dt>

<dd>
<p>sets the salt length to the digest length.</p>
</dd>
<dt><strong><a name="rsa_pss_saltlen_max" class="item"><strong>RSA_PSS_SALTLEN_MAX</strong></a></strong></dt>

<dd>
<p>sets the salt length to the maximum permissible value.</p>
</dd>
<dt><strong><a name="rsa_pss_saltlen_auto" class="item"><strong>RSA_PSS_SALTLEN_AUTO</strong></a></strong></dt>

<dd>
<p>causes the salt length to be automatically determined based on the
<strong>PSS</strong> block structure when verifying.  When signing, it has the same
meaning as <strong>RSA_PSS_SALTLEN_MAX</strong>.</p>
</dd>
</dl>
<p>The <code>EVP_PKEY_CTX_get_rsa_pss_saltlen()</code> function gets the RSA PSS salt length
for <em>ctx</em>. The padding mode must already have been set to
<strong>RSA_PKCS1_PSS_PADDING</strong>.</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_keygen_bits()</code> macro sets the RSA key length for
RSA key generation to <em>bits</em>. If not specified 2048 bits is used.</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_keygen_pubexp()</code> macro sets the public exponent value
for RSA key generation to <em>pubexp</em>. Currently it should be an odd integer. The
<em>pubexp</em> pointer is used internally by this function so it should not be
modified or freed after the call. If not specified 65537 is used.</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_keygen_primes()</code> macro sets the number of primes for
RSA key generation to <em>primes</em>. If not specified 2 is used.</p>
<p>The EVP_PKEY_CTX_set_rsa_mgf1_md_name() function sets the MGF1 digest for RSA
padding schemes to the digest named <em>mdname</em>. If the RSA algorithm
implementation for the selected provider supports it then the digest will be
fetched using the properties <em>mdprops</em>. If not explicitly set the signing
digest is used. The padding mode must have been set to <strong>RSA_PKCS1_OAEP_PADDING</strong>
or <strong>RSA_PKCS1_PSS_PADDING</strong>.</p>
<p>The EVP_PKEY_CTX_set_rsa_mgf1_md() function does the same as
EVP_PKEY_CTX_set_rsa_mgf1_md_name() except that the name of the digest is
inferred from the supplied <em>md</em> and it is not possible to specify any
properties.</p>
<p>The EVP_PKEY_CTX_get_rsa_mgf1_md_name() function gets the name of the MGF1
digest algorithm for <em>ctx</em>. If not explicitly set the signing digest is used.
The padding mode must have been set to <strong>RSA_PKCS1_OAEP_PADDING</strong> or
<strong>RSA_PKCS1_PSS_PADDING</strong>.</p>
<p>The EVP_PKEY_CTX_get_rsa_mgf1_md() function does the same as
EVP_PKEY_CTX_get_rsa_mgf1_md_name() except that it returns a pointer to an
EVP_MD object instead. Note that only known, built-in EVP_MD objects will be
returned. The EVP_MD object may be NULL if the digest is not one of these (such
as a digest only implemented in a third party provider).</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_oaep_md_name()</code> function sets the message digest type
used in RSA OAEP to the digest named <em>mdname</em>.  If the RSA algorithm
implementation for the selected provider supports it then the digest will be
fetched using the properties <em>mdprops</em>. The padding mode must have been set to
<strong>RSA_PKCS1_OAEP_PADDING</strong>.</p>
<p>The <code>EVP_PKEY_CTX_set_rsa_oaep_md()</code> function does the same as
<code>EVP_PKEY_CTX_set_rsa_oaep_md_name()</code> except that the name of the digest is
inferred from the supplied <em>md</em> and it is not possible to specify any
properties.</p>
<p>The <code>EVP_PKEY_CTX_get_rsa_oaep_md_name()</code> function gets the message digest
algorithm name used in RSA OAEP and stores it in the buffer <em>name</em> which is of
size <em>namelen</em>. The padding mode must have been set to
<strong>RSA_PKCS1_OAEP_PADDING</strong>. The buffer should be sufficiently large for any
expected digest algorithm names or the function will fail.</p>
<p>The <code>EVP_PKEY_CTX_get_rsa_oaep_md()</code> function does the same as
<code>EVP_PKEY_CTX_get_rsa_oaep_md_name()</code> except that it returns a pointer to an
EVP_MD object instead. Note that only known, built-in EVP_MD objects will be
returned. The EVP_MD object may be NULL if the digest is not one of these (such
as a digest only implemented in a third party provider).</p>
<p>The EVP_PKEY_CTX_set0_rsa_oaep_label() function sets the RSA OAEP label to
<em>label</em> and its length to <em>len</em>. If <em>label</em> is NULL or <em>len</em> is 0,
the label is cleared. The library takes ownership of the label so the
caller should not free the original memory pointed to by <em>label</em>.
The padding mode must have been set to <strong>RSA_PKCS1_OAEP_PADDING</strong>.</p>
<p>The EVP_PKEY_CTX_get0_rsa_oaep_label() function gets the RSA OAEP label to
<em>label</em>. The return value is the label length. The padding mode
must have been set to <strong>RSA_PKCS1_OAEP_PADDING</strong>. The resulting pointer is owned
by the library and should not be freed by the caller.</p>
<p><strong>RSA_PKCS1_WITH_TLS_PADDING</strong> is used when decrypting an RSA encrypted TLS
pre-master secret in a TLS ClientKeyExchange message. It is the same as
RSA_PKCS1_PADDING except that it additionally verifies that the result is the
correct length and the first two bytes are the protocol version initially
requested by the client. If the encrypted content is publicly invalid then the
decryption will fail. However, if the padding checks fail then decryption will
still appear to succeed but a random TLS premaster secret will be returned
instead. This padding mode accepts two parameters which can be set using the
<em>EVP_PKEY_CTX_set_params(3)</em> function. These are
OSSL_ASYM_CIPHER_PARAM_TLS_CLIENT_VERSION and
OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION, both of which are expected to be
unsigned integers. Normally only the first of these will be set and represents
the TLS protocol version that was first requested by the client (e.g. 0x0303 for
TLSv1.2, 0x0302 for TLSv1.1 etc). Historically some buggy clients would use the
negotiated protocol version instead of the protocol version first requested. If
this behaviour should be tolerated then
OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION should be set to the actual
negotiated protocol version. Otherwise it should be left unset.</p>
<p>
</p>
<h2><a name="dsa_parameters">DSA parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_dsa_paramgen_bits()</code> macro sets the number of bits used
for DSA parameter generation to <em>nbits</em>. If not specified, 2048 is used.</p>
<p>The <code>EVP_PKEY_CTX_set_dsa_paramgen_q_bits()</code> macro sets the number of bits in the
subprime parameter <em>q</em> for DSA parameter generation to <em>qbits</em>. If not
specified, 224 is used. If a digest function is specified below, this parameter
is ignored and instead, the number of bits in <em>q</em> matches the size of the
digest.</p>
<p>The <code>EVP_PKEY_CTX_set_dsa_paramgen_md()</code> macro sets the digest function used for
DSA parameter generation to <em>md</em>. If not specified, one of SHA-1, SHA-224, or
SHA-256 is selected to match the bit length of <em>q</em> above.</p>
<p>
</p>
<h2><a name="dh_parameters">DH parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_dh_paramgen_prime_len()</code> macro sets the length of the DH
prime parameter <em>p</em> for DH parameter generation. If this macro is not called
then 2048 is used. Only accepts lengths greater than or equal to 256.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_paramgen_subprime_len()</code> macro sets the length of the DH
optional subprime parameter <em>q</em> for DH parameter generation. The default is
256 if the prime is at least 2048 bits long or 160 otherwise. The DH
paramgen type must have been set to <strong>DH_PARAMGEN_TYPE_FIPS_186_2</strong> or
<strong>DH_PARAMGEN_TYPE_FIPS_186_4</strong>.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_paramgen_generator()</code> macro sets DH generator to <em>gen</em>
for DH parameter generation. If not specified 2 is used.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_paramgen_type()</code> macro sets the key type for DH
parameter generation. The supported parameters are:</p>
<dl>
<dt><strong><a name="dh_paramgen_type_generator" class="item"><strong>DH_PARAMGEN_TYPE_GENERATOR</strong></a></strong></dt>

<dd>
<p>Uses a generator g (PKCS#3 format).</p>
</dd>
<dt><strong><a name="dh_paramgen_type_fips_186_2" class="item"><strong>DH_PARAMGEN_TYPE_FIPS_186_2</strong></a></strong></dt>

<dd>
<p>FIPS186-2 FFC parameter generator (X9.42 DH).</p>
</dd>
<dt><strong><a name="dh_paramgen_type_fips_186_4" class="item"><strong>DH_PARAMGEN_TYPE_FIPS_186_4</strong></a></strong></dt>

<dd>
<p>FIPS186-4 FFC parameter generator.</p>
</dd>
</dl>
<p>The default is <strong>DH_PARAMGEN_TYPE_GENERATOR</strong>.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_pad()</code> function sets the DH padding mode.
If <em>pad</em> is 1 the shared secret is padded with zeros up to the size of the DH
prime <em>p</em>.
If <em>pad</em> is zero (the default) then no padding is performed.</p>
<p><code>EVP_PKEY_CTX_set_dh_nid()</code> sets the DH parameters to values corresponding to
<em>nid</em> as defined in <a href="http://www.ietf.org/rfc/rfc7919.txt" class="rfc">RFC7919</a> or <a href="http://www.ietf.org/rfc/rfc3526.txt" class="rfc">RFC3526</a>. The <em>nid</em> parameter must be
<strong>NID_ffdhe2048</strong>, <strong>NID_ffdhe3072</strong>, <strong>NID_ffdhe4096</strong>, <strong>NID_ffdhe6144</strong>,
<strong>NID_ffdhe8192</strong>, <strong>NID_modp_1536</strong>, <strong>NID_modp_2048</strong>, <strong>NID_modp_3072</strong>,
<strong>NID_modp_4096</strong>, <strong>NID_modp_6144</strong>, <strong>NID_modp_8192</strong> or <strong>NID_undef</strong> to clear
the stored value. This macro can be called during parameter or key generation.
The nid parameter and the rfc5114 parameter are mutually exclusive.</p>
<p>The EVP_PKEY_CTX_set_dh_rfc5114() and EVP_PKEY_CTX_set_dhx_rfc5114() macros are
synonymous. They set the DH parameters to the values defined in <a href="http://www.ietf.org/rfc/rfc5114.txt" class="rfc">RFC5114</a>. The
<em>rfc5114</em> parameter must be 1, 2 or 3 corresponding to <a href="http://www.ietf.org/rfc/rfc5114.txt" class="rfc">RFC5114</a> sections
2.1, 2.2 and 2.3. or 0 to clear the stored value. This macro can be called
during parameter generation. The <em>ctx</em> must have a key type of
<strong>EVP_PKEY_DHX</strong>.
The rfc5114 parameter and the nid parameter are mutually exclusive.</p>
<p>
</p>
<h2><a name="dh_key_derivation_function_parameters">DH key derivation function parameters</a></h2>
<p>Note that all of the following functions require that the <em>ctx</em> parameter has
a private key type of <strong>EVP_PKEY_DHX</strong>. When using key derivation, the output of
<code>EVP_PKEY_derive()</code> is the output of the KDF instead of the DH shared secret.
The KDF output is typically used as a Key Encryption Key (KEK) that in turn
encrypts a Content Encryption Key (CEK).</p>
<p>The <code>EVP_PKEY_CTX_set_dh_kdf_type()</code> macro sets the key derivation function type
to <em>kdf</em> for DH key derivation. Possible values are <strong>EVP_PKEY_DH_KDF_NONE</strong>
and <strong>EVP_PKEY_DH_KDF_X9_42</strong> which uses the key derivation specified in <a href="http://www.ietf.org/rfc/rfc2631.txt" class="rfc">RFC2631</a>
(based on the keying algorithm described in X9.42). When using key derivation,
the <em>kdf_oid</em>, <em>kdf_md</em> and <em>kdf_outlen</em> parameters must also be specified.</p>
<p>The <code>EVP_PKEY_CTX_get_dh_kdf_type()</code> macro gets the key derivation function type
for <em>ctx</em> used for DH key derivation. Possible values are <strong>EVP_PKEY_DH_KDF_NONE</strong>
and <strong>EVP_PKEY_DH_KDF_X9_42</strong>.</p>
<p>The EVP_PKEY_CTX_set0_dh_kdf_oid() macro sets the key derivation function
object identifier to <em>oid</em> for DH key derivation. This OID should identify
the algorithm to be used with the Content Encryption Key.
The library takes ownership of the object identifier so the caller should not
free the original memory pointed to by <em>oid</em>.</p>
<p>The EVP_PKEY_CTX_get0_dh_kdf_oid() macro gets the key derivation function oid
for <em>ctx</em> used for DH key derivation. The resulting pointer is owned by the
library and should not be freed by the caller.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_kdf_md()</code> macro sets the key derivation function
message digest to <em>md</em> for DH key derivation. Note that <a href="http://www.ietf.org/rfc/rfc2631.txt" class="rfc">RFC2631</a> specifies
that this digest should be SHA1 but OpenSSL tolerates other digests.</p>
<p>The <code>EVP_PKEY_CTX_get_dh_kdf_md()</code> macro gets the key derivation function
message digest for <em>ctx</em> used for DH key derivation.</p>
<p>The <code>EVP_PKEY_CTX_set_dh_kdf_outlen()</code> macro sets the key derivation function
output length to <em>len</em> for DH key derivation.</p>
<p>The <code>EVP_PKEY_CTX_get_dh_kdf_outlen()</code> macro gets the key derivation function
output length for <em>ctx</em> used for DH key derivation.</p>
<p>The EVP_PKEY_CTX_set0_dh_kdf_ukm() macro sets the user key material to
<em>ukm</em> and its length to <em>len</em> for DH key derivation. This parameter is optional
and corresponds to the partyAInfo field in <a href="http://www.ietf.org/rfc/rfc2631.txt" class="rfc">RFC2631</a> terms. The specification
requires that it is 512 bits long but this is not enforced by OpenSSL.
The library takes ownership of the user key material so the caller should not
free the original memory pointed to by <em>ukm</em>.</p>
<p>The EVP_PKEY_CTX_get0_dh_kdf_ukm() macro gets the user key material for <em>ctx</em>.
The return value is the user key material length. The resulting pointer is owned
by the library and should not be freed by the caller.</p>
<p>
</p>
<h2><a name="ec_parameters">EC parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_ec_paramgen_curve_nid()</code> sets the EC curve for EC parameter
generation to <em>nid</em>. For EC parameter generation this macro must be called
or an error occurs because there is no default curve.
This function can also be called to set the curve explicitly when
generating an EC key.</p>
<p>The <code>EVP_PKEY_CTX_set_ec_param_enc()</code> macro sets the EC parameter encoding to
<em>param_enc</em> when generating EC parameters or an EC key. The encoding can be
<strong>OPENSSL_EC_EXPLICIT_CURVE</strong> for explicit parameters (the default in versions
of OpenSSL before 1.1.0) or <strong>OPENSSL_EC_NAMED_CURVE</strong> to use named curve form.
For maximum compatibility the named curve form should be used. Note: the
<strong>OPENSSL_EC_NAMED_CURVE</strong> value was added in OpenSSL 1.1.0; previous
versions should use 0 instead.</p>
<p>
</p>
<h2><a name="ecdh_parameters">ECDH parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_ecdh_cofactor_mode()</code> macro sets the cofactor mode to
<em>cofactor_mode</em> for ECDH key derivation. Possible values are 1 to enable
cofactor key derivation, 0 to disable it and -1 to clear the stored cofactor
mode and fallback to the private key cofactor mode.</p>
<p>The <code>EVP_PKEY_CTX_get_ecdh_cofactor_mode()</code> macro returns the cofactor mode for
<em>ctx</em> used for ECDH key derivation. Possible values are 1 when cofactor key
derivation is enabled and 0 otherwise.</p>
<p>
</p>
<h2><a name="ecdh_key_derivation_function_parameters">ECDH key derivation function parameters</a></h2>
<p>The <code>EVP_PKEY_CTX_set_ecdh_kdf_type()</code> macro sets the key derivation function type
to <em>kdf</em> for ECDH key derivation. Possible values are <strong>EVP_PKEY_ECDH_KDF_NONE</strong>
and <strong>EVP_PKEY_ECDH_KDF_X9_63</strong> which uses the key derivation specified in X9.63.
When using key derivation, the <em>kdf_md</em> and <em>kdf_outlen</em> parameters must
also be specified.</p>
<p>The <code>EVP_PKEY_CTX_get_ecdh_kdf_type()</code> macro returns the key derivation function
type for <em>ctx</em> used for ECDH key derivation. Possible values are
<strong>EVP_PKEY_ECDH_KDF_NONE</strong> and <strong>EVP_PKEY_ECDH_KDF_X9_63</strong>.</p>
<p>The <code>EVP_PKEY_CTX_set_ecdh_kdf_md()</code> macro sets the key derivation function
message digest to <em>md</em> for ECDH key derivation. Note that X9.63 specifies
that this digest should be SHA1 but OpenSSL tolerates other digests.</p>
<p>The <code>EVP_PKEY_CTX_get_ecdh_kdf_md()</code> macro gets the key derivation function
message digest for <em>ctx</em> used for ECDH key derivation.</p>
<p>The <code>EVP_PKEY_CTX_set_ecdh_kdf_outlen()</code> macro sets the key derivation function
output length to <em>len</em> for ECDH key derivation.</p>
<p>The <code>EVP_PKEY_CTX_get_ecdh_kdf_outlen()</code> macro gets the key derivation function
output length for <em>ctx</em> used for ECDH key derivation.</p>
<p>The EVP_PKEY_CTX_set0_ecdh_kdf_ukm() macro sets the user key material to <em>ukm</em>
for ECDH key derivation. This parameter is optional and corresponds to the
shared info in X9.63 terms. The library takes ownership of the user key material
so the caller should not free the original memory pointed to by <em>ukm</em>.</p>
<p>The EVP_PKEY_CTX_get0_ecdh_kdf_ukm() macro gets the user key material for <em>ctx</em>.
The return value is the user key material length. The resulting pointer is owned
by the library and should not be freed by the caller.</p>
<p>
</p>
<h2><a name="other_parameters">Other parameters</a></h2>
<p>The EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and EVP_PKEY_CTX_get1_id_len()
macros are used to manipulate the special identifier field for specific signature
algorithms such as SM2. The EVP_PKEY_CTX_set1_id() sets an ID pointed by <em>id</em> with
the length <em>id_len</em> to the library. The library takes a copy of the id so that
the caller can safely free the original memory pointed to by <em>id</em>. The
EVP_PKEY_CTX_get1_id_len() macro returns the length of the ID set via a previous
call to EVP_PKEY_CTX_set1_id(). The length is usually used to allocate adequate
memory for further calls to EVP_PKEY_CTX_get1_id(). The EVP_PKEY_CTX_get1_id()
macro returns the previously set ID value to caller in <em>id</em>. The caller should
allocate adequate memory space for the <em>id</em> before calling EVP_PKEY_CTX_get1_id().</p>
<p>
</p>
<hr />
<h1><a name="return_values">RETURN VALUES</a></h1>
<p><code>EVP_PKEY_CTX_set_params()</code> returns 1 for success or 0 otherwise.
<code>EVP_PKEY_CTX_settable_params()</code> returns an OSSL_PARAM array on success or NULL on
error.
It may also return NULL if there are no settable parameters available.</p>
<p>All other functions and macros described on this page return a positive value
for success and 0 or a negative value for failure. In particular a return value
of -2 indicates the operation is not supported by the public key algorithm.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><em>EVP_PKEY_CTX_new(3)</em>,
<em>EVP_PKEY_encrypt(3)</em>,
<em>EVP_PKEY_decrypt(3)</em>,
<em>EVP_PKEY_sign(3)</em>,
<em>EVP_PKEY_verify(3)</em>,
<em>EVP_PKEY_verify_recover(3)</em>,
<em>EVP_PKEY_derive(3)</em>,
<em>EVP_PKEY_keygen(3)</em></p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p><code>EVP_PKEY_CTX_get_signature_md()</code>, <code>EVP_PKEY_CTX_set_signature_md()</code>,
<code>EVP_PKEY_CTX_set_dh_pad()</code>, <code>EVP_PKEY_CTX_set_rsa_padding()</code>,
<code>EVP_PKEY_CTX_get_rsa_padding()</code>, EVP_PKEY_CTX_get_rsa_mgf1_md(),
EVP_PKEY_CTX_set_rsa_mgf1_md(), <code>EVP_PKEY_CTX_set_rsa_oaep_md()</code>,
<code>EVP_PKEY_CTX_get_rsa_oaep_md()</code>, EVP_PKEY_CTX_set0_rsa_oaep_label(),
EVP_PKEY_CTX_get0_rsa_oaep_label(), <code>EVP_PKEY_CTX_set_rsa_pss_saltlen()</code>,
<code>EVP_PKEY_CTX_get_rsa_pss_saltlen()</code>, were macros in OpenSSL 1.1.1 and below.
From OpenSSL 3.0 they are functions.</p>
<p><code>EVP_PKEY_CTX_get_rsa_oaep_md_name()</code>, EVP_PKEY_CTX_get_rsa_mgf1_md_name(),
EVP_PKEY_CTX_set_rsa_mgf1_md_name() and <code>EVP_PKEY_CTX_set_rsa_oaep_md_name()</code> were
added in OpenSSL 3.0.</p>
<p>The EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and
EVP_PKEY_CTX_get1_id_len() macros were added in 1.1.1, other functions were
added in OpenSSL 1.0.0.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright 2006-2018 The OpenSSL Project Authors. All Rights Reserved.</p>
<p>Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a>.</p>

</body>

</html>
