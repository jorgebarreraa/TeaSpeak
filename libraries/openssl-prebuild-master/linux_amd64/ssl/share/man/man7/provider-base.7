.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PROVIDER-BASE 7"
.TH PROVIDER-BASE 7 "2020-03-02" "3.0.0-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
provider\-base
\&\- The basic OpenSSL library <\-> provider functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/core_numbers.h>
\&
\& /*
\&  * None of these are actual functions, but are displayed like this for
\&  * the function signatures for functions that are offered as function
\&  * pointers in OSSL_DISPATCH arrays.
\&  */
\&
\& /* Functions offered by libcrypto to the providers */
\& const OSSL_ITEM *core_gettable_params(const OSSL_PROVIDER *prov);
\& int core_get_params(const OSSL_PROVIDER *prov, OSSL_PARAM params[]);
\& int core_thread_start(const OSSL_PROVIDER *prov,
\&                       OSSL_thread_stop_handler_fn handfn);
\& OPENSSL_CTX *core_get_library_context(const OSSL_PROVIDER *prov);
\& void core_new_error(const OSSL_PROVIDER *prov);
\& void core_set_error_debug(const OSSL_PROVIDER *prov,
\&                           const char *file, int line, const char *func);
\& void core_vset_error(const OSSL_PROVIDER *prov,
\&                      uint32_t reason, const char *fmt, va_list args);
\&
\& /*
\&  * Some OpenSSL functionality is directly offered to providers via
\&  * dispatch
\&  */
\& void *CRYPTO_malloc(size_t num, const char *file, int line);
\& void *CRYPTO_zalloc(size_t num, const char *file, int line);
\& void *CRYPTO_memdup(const void *str, size_t siz,
\&                     const char *file, int line);
\& char *CRYPTO_strdup(const char *str, const char *file, int line);
\& char *CRYPTO_strndup(const char *str, size_t s,
\&                      const char *file, int line);
\& void CRYPTO_free(void *ptr, const char *file, int line);
\& void CRYPTO_clear_free(void *ptr, size_t num,
\&                        const char *file, int line);
\& void *CRYPTO_realloc(void *addr, size_t num,
\&                      const char *file, int line);
\& void *CRYPTO_clear_realloc(void *addr, size_t old_num, size_t num,
\&                            const char *file, int line);
\& void *CRYPTO_secure_malloc(size_t num, const char *file, int line);
\& void *CRYPTO_secure_zalloc(size_t num, const char *file, int line);
\& void CRYPTO_secure_free(void *ptr, const char *file, int line);
\& void CRYPTO_secure_clear_free(void *ptr, size_t num,
\&                               const char *file, int line);
\& int CRYPTO_secure_allocated(const void *ptr);
\& void OPENSSL_cleanse(void *ptr, size_t len);
\& unsigned char *OPENSSL_hexstr2buf(const char *str, long *len);
\&
\& /* Functions offered by the provider to libcrypto */
\& void provider_teardown(void *provctx);
\& const OSSL_ITEM *provider_gettable_params(void *provctx);
\& int provider_get_params(void *provctx, OSSL_PARAM params[]);
\& const OSSL_ALGORITHM *provider_query_operation(void *provctx,
\&                                                int operation_id,
\&                                                const int *no_store);
\& const OSSL_ITEM *provider_get_reason_strings(void *provctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All \*(L"functions\*(R" mentioned here are passed as function pointers between
\&\fIlibcrypto\fR and the provider in \fB\s-1OSSL_DISPATCH\s0\fR arrays, in the call
of the provider initialization function.  See \*(L"Provider\*(R" in \fIprovider\fR\|(7)
for a description of the initialization function.
.PP
All these \*(L"functions\*(R" have a corresponding function type definition
named \fBOSSL_{name}_fn\fR, and a helper function to retrieve the
function pointer from a \fB\s-1OSSL_DISPATCH\s0\fR element named
\&\fBOSSL_get_{name}\fR.
For example, the \*(L"function\*(R" \fIcore_gettable_params()\fR has these:
.PP
.Vb 4
\& typedef OSSL_ITEM *
\&     (OSSL_core_gettable_params_fn)(const OSSL_PROVIDER *prov);
\& static ossl_inline OSSL_NAME_core_gettable_params_fn
\&     OSSL_get_core_gettable_params(const OSSL_DISPATCH *opf);
.Ve
.PP
\&\fB\s-1OSSL_DISPATCH\s0\fR arrays are indexed by numbers that are provided as
macros in \fIopenssl\-core_numbers.h\fR\|(7), as follows:
.PP
For \fIin\fR (the \fB\s-1OSSL_DISPATCH\s0\fR array passed from \fIlibcrypto\fR to the
provider):
.PP
.Vb 10
\& core_gettable_params           OSSL_FUNC_CORE_GETTABLE_PARAMS
\& core_get_params                OSSL_FUNC_CORE_GET_PARAMS
\& core_thread_start              OSSL_FUNC_CORE_THREAD_START
\& core_get_library_context       OSSL_FUNC_CORE_GET_LIBRARY_CONTEXT
\& core_new_error                 OSSL_FUNC_CORE_NEW_ERROR
\& core_set_error_debug           OSSL_FUNC_CORE_SET_ERROR_DEBUG
\& core_set_error                 OSSL_FUNC_CORE_SET_ERROR
\& CRYPTO_malloc                  OSSL_FUNC_CRYPTO_MALLOC
\& CRYPTO_zalloc                  OSSL_FUNC_CRYPTO_ZALLOC
\& CRYPTO_memdup                  OSSL_FUNC_CRYPTO_MEMDUP
\& CRYPTO_strdup                  OSSL_FUNC_CRYPTO_STRDUP
\& CRYPTO_strndup                 OSSL_FUNC_CRYPTO_STRNDUP
\& CRYPTO_free                    OSSL_FUNC_CRYPTO_FREE
\& CRYPTO_clear_free              OSSL_FUNC_CRYPTO_CLEAR_FREE
\& CRYPTO_realloc                 OSSL_FUNC_CRYPTO_REALLOC
\& CRYPTO_clear_realloc           OSSL_FUNC_CRYPTO_CLEAR_REALLOC
\& CRYPTO_secure_malloc           OSSL_FUNC_CRYPTO_SECURE_MALLOC
\& CRYPTO_secure_zalloc           OSSL_FUNC_CRYPTO_SECURE_ZALLOC
\& CRYPTO_secure_free             OSSL_FUNC_CRYPTO_SECURE_FREE
\& CRYPTO_secure_clear_free       OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE
\& CRYPTO_secure_allocated        OSSL_FUNC_CRYPTO_SECURE_ALLOCATED
\& BIO_new_file                   OSSL_FUNC_BIO_NEW_FILE
\& BIO_new_mem_buf                OSSL_FUNC_BIO_NEW_MEMBUF
\& BIO_read_ex                    OSSL_FUNC_BIO_READ_EX
\& BIO_free                       OSSL_FUNC_BIO_FREE
\& BIO_vprintf                    OSSL_FUNC_BIO_VPRINTF
\& OPENSSL_cleanse                OSSL_FUNC_OPENSSL_CLEANSE
\& OPENSSL_hexstr2buf             OSSL_FUNC_OPENSSL_HEXSTR2BUF
\& OSSL_SELF_TEST_set_callback    OSSL_FUNC_SELF_TEST_CB
.Ve
.PP
For \fI*out\fR (the \fB\s-1OSSL_DISPATCH\s0\fR array passed from the provider to
\&\fIlibcrypto\fR):
.PP
.Vb 5
\& provider_teardown              OSSL_FUNC_PROVIDER_TEARDOWN
\& provider_gettable_params       OSSL_FUNC_PROVIDER_GETTABLE_PARAMS
\& provider_get_params            OSSL_FUNC_PROVIDER_GET_PARAMS
\& provider_query_operation       OSSL_FUNC_PROVIDER_QUERY_OPERATION
\& provider_get_reason_strings    OSSL_FUNC_PROVIDER_GET_REASON_STRINGS
.Ve
.SS "Core functions"
.IX Subsection "Core functions"
\&\fIcore_gettable_params()\fR returns a constant array of descriptor
\&\fB\s-1OSSL_PARAM\s0\fR, for parameters that \fIcore_get_params()\fR can handle.
.PP
\&\fIcore_get_params()\fR retrieves \fIprov\fR parameters from the core.
See \*(L"Core parameters\*(R" below for a description of currently known
parameters.
.PP
\&\fIcore_get_library_context()\fR retrieves the library context in which the
\&\fB\s-1OSSL_PROVIDER\s0\fR object \fIprov\fR is stored.
This may sometimes be useful if the provider wishes to store a
reference to its context in the same library context.
.PP
\&\fIcore_new_error()\fR, \fIcore_set_error_debug()\fR and \fIcore_set_error()\fR are
building blocks for reporting an error back to the core, with
reference to the provider object \fIprov\fR.
.IP "\fIcore_new_error()\fR" 4
.IX Item "core_new_error()"
allocates a new thread specific error record.
.Sp
This corresponds to the OpenSSL function \fIERR_new\fR\|(3).
.IP "\fIcore_set_error_debug()\fR" 4
.IX Item "core_set_error_debug()"
sets debugging information in the current thread specific error
record.
The debugging information includes the name of the file \fIfile\fR, the
line \fIline\fR and the function name \fIfunc\fR where the error occurred.
.Sp
This corresponds to the OpenSSL function \fIERR_set_debug\fR\|(3).
.IP "\fIcore_set_error()\fR" 4
.IX Item "core_set_error()"
sets the \fIreason\fR for the error, along with any addition data.
The \fIreason\fR is a number defined by the provider and used to index
the reason strings table that's returned by
\&\fIprovider_get_reason_strings()\fR.
The additional data is given as a format string \fIfmt\fR and a set of
arguments \fIargs\fR, which are treated in the same manner as with
\&\fIBIO_vsnprintf()\fR.
\&\fIfile\fR and \fIline\fR may also be passed to indicate exactly where the
error occurred or was reported.
.Sp
This corresponds to the OpenSSL function \fIERR_vset_error\fR\|(3).
.PP
\&\fICRYPTO_malloc()\fR, \fICRYPTO_zalloc()\fR, \fICRYPTO_memdup()\fR, \fICRYPTO_strdup()\fR,
\&\fICRYPTO_strndup()\fR, \fICRYPTO_free()\fR, \fICRYPTO_clear_free()\fR,
\&\fICRYPTO_realloc()\fR, \fICRYPTO_clear_realloc()\fR, \fICRYPTO_secure_malloc()\fR,
\&\fICRYPTO_secure_zalloc()\fR, \fICRYPTO_secure_free()\fR,
\&\fICRYPTO_secure_clear_free()\fR, \fICRYPTO_secure_allocated()\fR,
\&\fIBIO_new_file()\fR, \fIBIO_new_mem_buf()\fR, \fIBIO_read_ex()\fR, \fIBIO_free()\fR,
\&\fIBIO_vprintf()\fR, \fIOPENSSL_cleanse()\fR, and \fIOPENSSL_hexstr2buf()\fR
correspond exactly to the public functions with the same name.
As a matter of fact, the pointers in the \fB\s-1OSSL_DISPATCH\s0\fR array are
direct pointers to those public functions.
\&\fIOSSL_SELF_TEST_set_callback()\fR is used to set an optional callback that can be
passed into a provider. This may be ignored by a provider.
.SS "Provider functions"
.IX Subsection "Provider functions"
\&\fIprovider_teardown()\fR is called when a provider is shut down and removed
from the core's provider store.
It must free the passed \fIprovctx\fR.
.PP
\&\fIprovider_gettable_params()\fR should return a constant array of
descriptor \fB\s-1OSSL_PARAM\s0\fR, for parameters that \fIprovider_get_params()\fR
can handle.
.PP
\&\fIprovider_get_params()\fR should process the \fB\s-1OSSL_PARAM\s0\fR array
\&\fIparams\fR, setting the values of the parameters it understands.
.PP
\&\fIprovider_query_operation()\fR should return a constant \fB\s-1OSSL_ALGORITHM\s0\fR
that corresponds to the given \fIoperation_id\fR.
It should indicate if the core may store a reference to this array by
setting \fI*no_store\fR to 0 (core may store a reference) or 1 (core may
not store a reference).
.PP
\&\fIprovider_get_reason_strings()\fR should return a constant \fB\s-1OSSL_ITEM\s0\fR
array that provides reason strings for reason codes the provider may
use when reporting errors using \fIcore_put_error()\fR.
.PP
None of these functions are mandatory, but a provider is fairly
useless without at least \fIprovider_query_operation()\fR, and
\&\fIprovider_gettable_params()\fR is fairly useless if not accompanied by
\&\fIprovider_get_params()\fR.
.SS "Core parameters"
.IX Subsection "Core parameters"
\&\fIcore_get_params()\fR understands the following known parameters:
.ie n .IP """openssl-version""" 4
.el .IP "``openssl-version''" 4
.IX Item "openssl-version"
This is a \fB\s-1OSSL_PARAM_UTF8_PTR\s0\fR type of parameter, pointing at the
OpenSSL libraries' full version string, i.e. the string expanded from
the macro \fB\s-1OPENSSL_VERSION_STR\s0\fR.
.ie n .IP """provider-name""" 4
.el .IP "``provider-name''" 4
.IX Item "provider-name"
This is a \fB\s-1OSSL_PARAM_UTF8_PTR\s0\fR type of parameter, pointing at the
OpenSSL libraries' idea of what the calling provider is called.
.PP
Additionally, provider specific configuration parameters from the
config file are available, in dotted name form.
The dotted name form is a concatenation of section names and final
config command name separated by periods.
.PP
For example, let's say we have the following config example:
.PP
.Vb 1
\& openssl_conf = openssl_init
\&
\& [openssl_init]
\& providers = providers_sect
\&
\& [providers_sect]
\& foo = foo_sect
\&
\& [foo_sect]
\& activate = 1
\& data1 = 2
\& data2 = str
\& more = foo_more
\&
\& [foo_more]
\& data3 = foo,bar
.Ve
.PP
The provider will have these additional parameters available:
.ie n .IP """activate""" 4
.el .IP "``activate''" 4
.IX Item "activate"
pointing at the string \*(L"1\*(R"
.ie n .IP """data1""" 4
.el .IP "``data1''" 4
.IX Item "data1"
pointing at the string \*(L"2\*(R"
.ie n .IP """data2""" 4
.el .IP "``data2''" 4
.IX Item "data2"
pointing at the string \*(L"str\*(R"
.ie n .IP """more.data3""" 4
.el .IP "``more.data3''" 4
.IX Item "more.data3"
pointing at the string \*(L"foo,bar\*(R"
.PP
For more information on handling parameters, see \s-1\fIOSSL_PARAM\s0\fR\|(3) as
\&\fIOSSL_PARAM_int\fR\|(3).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This is an example of a simple provider made available as a
dynamically loadable module.
It implements the fictitious algorithm \f(CW\*(C`FOO\*(C'\fR for the fictitious
operation \f(CW\*(C`BAR\*(C'\fR.
.PP
.Vb 3
\& #include <malloc.h>
\& #include <openssl/core.h>
\& #include <openssl/core_numbers.h>
\&
\& /* Errors used in this provider */
\& #define E_MALLOC       1
\&
\& static const OSSL_ITEM reasons[] = {
\&     { E_MALLOC, "memory allocation failure" }.
\&     { 0, NULL } /* Termination */
\& };
\&
\& /*
\&  * To ensure we get the function signature right, forward declare
\&  * them using function types provided by openssl/core_numbers.h
\&  */
\& OSSL_OP_bar_newctx_fn foo_newctx;
\& OSSL_OP_bar_freectx_fn foo_freectx;
\& OSSL_OP_bar_init_fn foo_init;
\& OSSL_OP_bar_update_fn foo_update;
\& OSSL_OP_bar_final_fn foo_final;
\&
\& OSSL_provider_query_operation_fn p_query;
\& OSSL_provider_get_reason_strings_fn p_reasons;
\& OSSL_provider_teardown_fn p_teardown;
\&
\& OSSL_provider_init_fn OSSL_provider_init;
\&
\& OSSL_core_put_error *c_put_error = NULL;
\&
\& /* Provider context */
\& struct prov_ctx_st {
\&     OSSL_PROVIDER *prov;
\& }
\&
\& /* operation context for the algorithm FOO */
\& struct foo_ctx_st {
\&     struct prov_ctx_st *provctx;
\&     int b;
\& };
\&
\& static void *foo_newctx(void *provctx)
\& {
\&     struct foo_ctx_st *fooctx = malloc(sizeof(*fooctx));
\&
\&     if (fooctx != NULL)
\&         fooctx\->provctx = provctx;
\&     else
\&         c_put_error(provctx\->prov, E_MALLOC, _\|_FILE_\|_, _\|_LINE_\|_);
\&     return fooctx;
\& }
\&
\& static void foo_freectx(void *fooctx)
\& {
\&     free(fooctx);
\& }
\&
\& static int foo_init(void *vfooctx)
\& {
\&     struct foo_ctx_st *fooctx = vfooctx;
\&
\&     fooctx\->b = 0x33;
\& }
\&
\& static int foo_update(void *vfooctx, unsigned char *in, size_t inl)
\& {
\&     struct foo_ctx_st *fooctx = vfooctx;
\&
\&     /* did you expect something serious? */
\&     if (inl == 0)
\&         return 1;
\&     for (; inl\-\- > 0; in++)
\&         *in ^= fooctx\->b;
\&     return 1;
\& }
\&
\& static int foo_final(void *vfooctx)
\& {
\&     struct foo_ctx_st *fooctx = vfooctx;
\&
\&     fooctx\->b = 0x66;
\& }
\&
\& static const OSSL_DISPATCH foo_fns[] = {
\&     { OSSL_FUNC_BAR_NEWCTX, (void (*)(void))foo_newctx },
\&     { OSSL_FUNC_BAR_FREECTX, (void (*)(void))foo_freectx },
\&     { OSSL_FUNC_BAR_INIT, (void (*)(void))foo_init },
\&     { OSSL_FUNC_BAR_UPDATE, (void (*)(void))foo_update },
\&     { OSSL_FUNC_BAR_FINAL, (void (*)(void))foo_final },
\&     { 0, NULL }
\& };
\&
\& static const OSSL_ALGORITHM bars[] = {
\&     { "FOO", "provider=chumbawamba", foo_fns },
\&     { NULL, NULL, NULL }
\& };
\&
\& static const OSSL_ALGORITHM *p_query(void *provctx, int operation_id,
\&                                      int *no_store)
\& {
\&     switch (operation_id) {
\&     case OSSL_OP_BAR:
\&         return bars;
\&     }
\&     return NULL;
\& }
\&
\& static const OSSL_ITEM *p_reasons(void *provctx)
\& {
\&     return reasons;
\& }
\&
\& static void p_teardown(void *provctx)
\& {
\&     free(provctx);
\& }
\&
\& static const OSSL_DISPATCH prov_fns[] = {
\&     { OSSL_FUNC_PROVIDER_TEARDOWN, (void (*)(void))p_teardown },
\&     { OSSL_FUNC_PROVIDER_QUERY_OPERATION, (void (*)(void))p_query },
\&     { OSSL_FUNC_PROVIDER_GET_REASON_STRINGS, (void (*)(void))p_reasons },
\&     { 0, NULL }
\& };
\&
\& int OSSL_provider_init(const OSSL_PROVIDER *provider,
\&                        const OSSL_DISPATCH *in,
\&                        const OSSL_DISPATCH **out,
\&                        void **provctx)
\& {
\&     struct prov_ctx_st *pctx = NULL;
\&
\&     for (; in\->function_id != 0; in++)
\&         switch (in\->function_id) {
\&         case OSSL_FUNC_CORE_PUT_ERROR:
\&             c_put_error = OSSL_get_core_put_error(in);
\&             break;
\&         }
\&
\&     *out = prov_fns;
\&
\&     if ((pctx = malloc(sizeof(*pctx))) == NULL) {
\&         /*
\&          * ALEA IACTA EST, if the core retrieves the reason table
\&          * regardless, that string will be displayed, otherwise not.
\&          */
\&         c_put_error(provider, E_MALLOC, _\|_FILE_\|_, _\|_LINE_\|_);
\&         return 0;
\&     }
\&     return 1;
\& }
.Ve
.PP
This relies on a few things existing in \fIopenssl/core_numbers.h\fR:
.PP
.Vb 1
\& #define OSSL_OP_BAR            4711
\&
\& #define OSSL_FUNC_BAR_NEWCTX      1
\& typedef void *(OSSL_OP_bar_newctx_fn)(void *provctx);
\& static ossl_inline OSSL_get_bar_newctx(const OSSL_DISPATCH *opf)
\& { return (OSSL_OP_bar_newctx_fn *)opf\->function; }
\&
\& #define OSSL_FUNC_BAR_FREECTX     2
\& typedef void (OSSL_OP_bar_freectx_fn)(void *ctx);
\& static ossl_inline OSSL_get_bar_newctx(const OSSL_DISPATCH *opf)
\& { return (OSSL_OP_bar_freectx_fn *)opf\->function; }
\&
\& #define OSSL_FUNC_BAR_INIT        3
\& typedef void *(OSSL_OP_bar_init_fn)(void *ctx);
\& static ossl_inline OSSL_get_bar_init(const OSSL_DISPATCH *opf)
\& { return (OSSL_OP_bar_init_fn *)opf\->function; }
\&
\& #define OSSL_FUNC_BAR_UPDATE      4
\& typedef void *(OSSL_OP_bar_update_fn)(void *ctx,
\&                                       unsigned char *in, size_t inl);
\& static ossl_inline OSSL_get_bar_update(const OSSL_DISPATCH *opf)
\& { return (OSSL_OP_bar_update_fn *)opf\->function; }
\&
\& #define OSSL_FUNC_BAR_FINAL       5
\& typedef void *(OSSL_OP_bar_final_fn)(void *ctx);
\& static ossl_inline OSSL_get_bar_final(const OSSL_DISPATCH *opf)
\& { return (OSSL_OP_bar_final_fn *)opf\->function; }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIprovider\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The concept of providers and everything surrounding them was
introduced in OpenSSL 3.0.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
